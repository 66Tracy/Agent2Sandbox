# Latest Design Demand
项目经过多期的更新，已经实现了初步的架构。现在我做一个总结，然后提出新的设计需求。

## 初始化
初始的项目实现目标为init.md，但彼时需求仍不完善，只有初步的目标。

## 中期-与沙箱交互进行优化
基于OpenSandbox开源项目实现沙箱交互。接入沙箱服务器后，基于与沙箱的交互优化，重新优化了代码。
**OpenSandbox本地仓库地址（最新可参考其中的教程）** : /Users/chenxi/Desktop/WorkPlace/agent2env/OpenSandbox

## 需求清单
对比原来的版本，旧的Agent模块将移除，取而代之的是LLM Proxy直接与Sandbox通信。整体设计更通用化、兼容性更好。
| **功能**           | **需求说明**                                                                             | **衍生出的设计需求**                                                           |
|------------------|--------------------------------------------------------------------------------------|------------------------------------------------------------------------|
| 任务定义模块           | 使用json或yaml定义任务必要字段：任务名称/使用镜像/MCP地址/使用哪个LLM/任务目标/entry point（启动脚本）/结束条件/输出交付件        | 1）容器内需要有相应的启动脚本，启动容器后自动开始执行；2）架构上需要有任务完成时交付件回传的通道；3）容器内停止响应视为任务失败的监控机制 |
| MCP服务-remote     | 可以共享的公共MCP服务器，提供基本的接口                                                                | 并行化通信需求                                                                |
| MCP服务-local      | sandbox内自身配套的MCP服务，例如容器内数据库查询等                                                       | 容器自身定制化，与外部架构解耦                                                        |
| LLM-Proxy        | 模型的中央代理，统一管理所有的llm接口，沙箱与LLM-Proxy通信，LLM-Proxy根据请求字段调用外部api；同时根据沙箱id可以归档管理各个沙箱的所有对话历史 | 本身是一个服务，同时配备数据管理/存档的能力                                                 |
| Agent框架          | 各种sandbox镜像自身定制，支持claude-code\qwen-agent\opencode\gemini-cli\..，但需要适配任务定义模块          | 容器自身定制化，与外部架构解耦；唯一的联系是根据任务模块的MCP字段绑定服务，以及根据任务模块的交付路径需要回传可能需要的交付件       |
| Sandbox Server模块 | 使用现用的OpenSandbox即可                                                                   | 部署在K8s集群上，所有sandbox都在K8s上                                              |

## 技术细节
· 任务定义的 JSON/YAML 配置文件，你期望放在哪里？是单独的配置目录还是与代码库在一起？ → 项目内 tasks/ 目录

· MCP（Model Context Protocol）服务的通信协议是什么？ → 建议分情况采用多协议分层架构的设计，核心采用gRPC over HTTP/2；根据内部集群的K8s部署的remote MCP所有沙箱可以共享；沙箱内的local MCP；以及支持连接互联网的MCP；三种场景逐步扩展

· LLM-Proxy 与 Sandbox 之间的通信方式是什么？ → 基于OpenAI API或者Anthropic API形式的接口实现，初步只考虑最通用的两种格式

· 任务完成后的交付件回传方式是什么？ → 暂时定使用OpenSandbox API（需要确定一下），根据后续实现情况可能考虑转用上传通道\共享存储等等机制

## 步骤
**Step-1：** 分析需求，明确细节，书写设计文档  
**Step-2：** 人工审核设计文档  
**Step-3：** 设计demo实现，暂时使用本地OpenSandbox服务代替K8s服务（此阶段不考虑通信细节，使用http+docker）
**Step-4：** 实现一个单机可运行的demo，初步设定为使用code-interpreter镜像内置的claude-code功能完成一些agent功能（待定）  
**Step-5：** 重构项目的文件结构，移除无关文档，重新书写REAMDE.md